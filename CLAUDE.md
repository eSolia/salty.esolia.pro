# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Important: Security Documentation

When making any security-related changes to Salty, you MUST update the Security Changelog in SECURITY.md. This includes:

- New security features or utilities
- Security configuration changes
- New security tests or scanning tools
- Security header modifications
- Cryptographic changes
- Input validation improvements
- Rate limiting changes
- Any security bug fixes

The Security Changelog is located in SECURITY.md under the "üìù Security Changelog" section.

## Initial Setup

### Enable Git Hooks

To prevent formatting issues in CI, enable the pre-commit hook:

```bash
git config core.hooksPath .githooks
```

This will automatically format code before each commit, preventing formatting failures in CI.

## Common Development Commands

### Development

```bash
# Start development server with file watching
deno task dev

# Run production server
deno task start
```

### Release Management

```bash
# Create a patch release (1.2.3 -> 1.2.4)
deno task release:patch

# Create a minor release (1.2.3 -> 1.3.0)
deno task release:minor

# Create a major release (1.2.3 -> 2.0.0)
deno task release:major

# Rollback a release
deno task rollback

# Preview changelog without creating release
deno task changelog
```

### Code Quality

```bash
# Format code according to project standards
deno fmt

# Lint code
deno lint

# Type check ALL TypeScript files
deno check **/*.ts
# Or alternatively:
deno check *.ts scripts/*.ts
```

### Release Automation

Always use the `--skip-confirmation` flag for non-interactive releases:

```bash
deno task release:patch -- --skip-confirmation  # Non-interactive patch release
deno task release:minor -- --skip-confirmation  # Non-interactive minor release
deno task release:major -- --skip-confirmation  # Non-interactive major release
```

### Preflight Checks Before Release

ALWAYS perform these checks before any release:

```bash
# 1. Format all code
deno fmt

# 2. Run linter
deno lint

# 3. Type check ALL TypeScript files (not just server.ts!)
deno check **/*.ts

# 4. Run all tests
deno test

# 5. Run security-specific tests
deno test --allow-env --allow-read security-utils_test.ts
deno test --allow-env salty_security_test.ts

# 6. Check for uncommitted changes
git status

# 7. Verify version.ts exports match server.ts imports
grep "import.*version.ts" server.ts
```

## High-Level Architecture

### Core Application Flow

1. **server.ts** - Main entry point that sets up Express-like middleware chain for security, logging, rate limiting, and routing
2. **salty.ts** - Pure cryptographic functions exposed both as ES6 modules for browser and TypeScript imports for server
3. **logger.ts** - Structured logging with category-based filtering and webhook integration for critical alerts
4. **telemetry.ts** - OpenTelemetry-style tracing for performance monitoring
5. **version.ts** - Auto-generated by Nagare release tool, single source of truth for version metadata

### Security Architecture

- **Client-side encryption**: All crypto operations happen in browser via Web Crypto API
- **Server never sees plaintext**: Only processes encrypted payloads
- **Defense in depth**: Rate limiting (20 req/hour), input validation, security headers (CSP, HSTS)
- **API authentication**: Optional via API_KEY environment variable

### Cryptographic Design

- **Key Derivation**: PBKDF2-SHA512 with 600,000 iterations
- **Encryption**: AES-GCM-256 with 12-byte IV
- **Encoding**: basE91 for compact, portable output
- **Salt**: Server-configured via SALT_HEX environment variable

### Release Workflow

Nagare automates the entire release process:

1. Updates version in deno.json, README.md badges, and regenerates version.ts
2. Creates git tag and GitHub release with changelog
3. Handles rollback if deployment fails
4. Maintains semantic versioning compliance

### Environment Configuration

Required:

- `SALT_HEX`: 32-character hex string (16 bytes) for cryptographic salt

Optional:

- `API_KEY`: Base64 string for API endpoint authentication
- `LOG_LEVEL`: DEBUG, INFO, WARN, ERROR, SECURITY, CRITICAL (default: INFO)
- `LOG_FORMAT`: json or text (default: json)
- `WEBHOOK_URL`: For critical alert notifications
- `NODE_ENV`: development, staging, or production

### Key Implementation Details

- **TypeScript transpilation**: Server automatically transpiles salty.ts for browser ES6 modules
- **Multi-language support**: Japanese (/) and English (/en/) with IBM Plex Sans JP font
- **URL pre-population**: Supports URL parameters for database integration workflows
  - `?payload=` - Pre-populate encrypted payload field
  - `?sui=1` - Activate sharing UI mode (hides password generator and strength assessment)
- **Health endpoint**: GET /health provides comprehensive system metrics
- **Static asset serving**: Images served with appropriate MIME types from /img/

## Security & Compliance Standards

### OWASP Top 10 Security Verification

Before implementing any code changes, verify against current OWASP Top 10:

#### A01 - Broken Access Control

- **API Authentication**: Validate API_KEY for all /api/* endpoints when configured
- **Rate Limiting**: Enforce 20 requests/hour per IP to prevent abuse
- **File Access**: Restrict static file serving to specific paths (/img/, /en/, client files)
- **CORS Policy**: Implement restrictive CORS headers for API endpoints

#### A02 - Cryptographic Failures

- **Strong Algorithms**: AES-GCM-256 encryption with PBKDF2-SHA512 (600,000 iterations)
- **Key Management**: SALT_HEX must be cryptographically secure and unique per deployment
- **Client-Side Encryption**: Plaintext never transmitted to or processed by server
- **Secure Random Generation**: Use crypto.getRandomValues() for IV generation
- **No Hardcoded Secrets**: All secrets via environment variables

#### A03 - Injection

- **Input Validation**: Strict validation for payload (1MB) and key (1KB) sizes
- **Content Type Validation**: Enforce application/json for API requests
- **Output Encoding**: Proper HTML escaping in error messages
- **No Dynamic Code Execution**: No eval() or Function() constructor usage
- **Safe URL Parameter Handling**: Sanitize ?payload= parameter input

#### A04 - Insecure Design

- **Separation of Concerns**: Crypto operations isolated in browser, server handles routing only
- **Fail Securely**: Invalid decryption returns null, not error details
- **Defense in Depth**: Multiple security layers (rate limiting, input validation, headers)
- **Minimal Attack Surface**: Limited endpoints, no database, no user accounts

#### A05 - Security Misconfiguration

- **Security Headers**: Comprehensive CSP, HSTS, X-Frame-Options, X-Content-Type-Options
- **Error Handling**: Generic error messages, no stack traces or sensitive data exposure
- **Environment Validation**: Verify required SALT_HEX on startup
- **Secure Defaults**: Production-ready security settings by default
- **No Debug Info**: LOG_LEVEL controls verbosity, no debug info in production

#### A06 - Vulnerable Components

- **Deno Runtime**: Leverage Deno's secure-by-default runtime
- **Minimal Dependencies**: No external npm packages, only Deno std library
- **Regular Updates**: Monitor Deno security advisories
- **Dependency Pinning**: Lock Deno std library versions in imports

#### A07 - Authentication Failures

- **API Key Protection**: Constant-time comparison for API_KEY validation
- **No User Authentication**: Design eliminates user account vulnerabilities
- **Rate Limiting**: Prevent brute force attempts on API endpoints
- **No Session Management**: Stateless design prevents session attacks

#### A08 - Software/Data Integrity Failures

- **Authenticated Encryption**: AES-GCM provides integrity verification
- **No Code Auto-Updates**: Static deployment, no dynamic code loading
- **Version Integrity**: version.ts tracks build metadata and git commit
- **Deployment Validation**: Health endpoint verifies system integrity

#### A09 - Logging/Monitoring Failures

- **Structured Logging**: Category-based logging with security events
- **Security Event Tracking**: Log rate limit violations, API auth failures
- **No Sensitive Data in Logs**: Exclude keys, plaintext, and API tokens
- **Webhook Alerts**: Critical security events sent to configured webhook
- **Health Monitoring**: /health endpoint provides system metrics

#### A10 - Server-Side Request Forgery (SSRF)

- **No External Requests**: Server makes no outbound HTTP requests
- **Static Resources Only**: No dynamic resource fetching
- **Webhook Validation**: Webhook URL validated if configured
- **No User-Controlled URLs**: Server doesn't process user-provided URLs

### Security Review Process

When reviewing or implementing changes:

1. **Crypto First**: Verify cryptographic implementations against best practices
2. **Input Validation**: Check all user inputs for size, type, and content
3. **Error Handling**: Ensure no sensitive data leakage in error messages
4. **Logging Review**: Verify security events are logged without sensitive data
5. **Header Validation**: Confirm security headers are properly set

### Required Security Checks

For every code change:

- Validate input sanitization (payload, key, API requests)
- Verify cryptographic parameter integrity
- Check error messages for information disclosure
- Ensure rate limiting is enforced
- Validate security headers are maintained
- Review logs for sensitive data exposure

### Security Testing Guidelines

- Test with oversized payloads (>1MB) and keys (>1KB)
- Verify rate limiting blocks after 20 requests/hour
- Test API authentication with invalid keys
- Ensure malformed requests return generic errors
- Validate CORS behavior for cross-origin requests
- Test with invalid basE91 encoded payloads

### Commit Message Standards

Use conventional commits with security annotations when applicable:

```
feat: add input validation for API endpoints

InfoSec: Prevents injection attacks and validates request size limits
```

```
fix: improve rate limiting accuracy

InfoSec: Fixes potential bypass in rate limit calculation
```

```
refactor: simplify error handling logic

InfoSec: No security impact - maintains same error disclosure policy
```

Include "InfoSec:" prefix in commit messages when changes affect:

- Input validation or sanitization
- Cryptographic operations
- Authentication/authorization
- Error handling or logging
- Security headers or policies
- Rate limiting or DoS protection

### Critical Development Notes

1. **Security Testing**: When adding features, create corresponding security tests alongside
   functional tests
2. **File Updates**: Always use line-anchored regex patterns to prevent corruption and validate
   inputs
3. **Error Handling**: Provide actionable error messages with suggestions (no sensitive data
   exposure)
4. **Git State**: Many operations require clean git state - validate early and log security events
5. **Pre-flight**: Always run `deno fmt`, `deno check **/*.ts`, `deno lint`, `deno test` before
   staging a commit
6. **Attribution**: Don't add "Generated with Claude Code" or "Co-Authored-By: Claude" to commit
   messages or PRs. The fact that CLAUDE.md is present, makes it obvious that Claude is being used
7. **Git Commits**: Use "conventional commits" style to make commit messages, including sufficient
   detail so that a person reading in the future, will be able to understand what the commit was.
   **InfoSec Impact**: Include an InfoSec comment in commit messages when changes have security
   implications. Format: "InfoSec: [brief description of security impact/consideration]"

   Examples:
   - `feat: add input validation to CLI args\n\nInfoSec: Prevents injection attacks through command line parameters`
   - `fix: update GitHub API token handling\n\nInfoSec: Improves credential security and reduces token exposure risk`
   - `refactor: simplify file processing logic\n\nInfoSec: No security impact - code organization only`
   - `docs: update README installation steps` (no InfoSec comment needed)
8. **Documentation Updates**: After functionality is added, update the markdown documentation
   accordingly
9. **Git Merging**: When merging master changes to an active branch, make sure both branches are
   pulled and up to date first
10. **Security Documentation**: Document all security-related decisions and their rationale for ISO 27001 compliance
11. **TypeScript Strictness**: NEVER use `any` type. The project has strict linting that forbids `any` types. Always use proper types:
    - Use specific interfaces and types from imports
    - Use type assertions properly: `value as SpecificType` not `value as any`
    - This prevents CI failures and ensures type safety
12. **CI Test Considerations**: Some tests may need to be skipped in CI environments. Use:
    ```typescript
    Deno.test({
      ignore: Deno.env.get("CI") === "true",
      name: "Test name",
    }, async (t) => {/* test code */});
    ```
    This is particularly important for tests that require actual git repositories or file system operations that may conflict in CI

## Programming Paradigm & Code Consistency

Salty follows a **hybrid programming paradigm** combining object-oriented and functional programming. See [PROGRAMMING-PARADIGM.md](./PROGRAMMING-PARADIGM.md) for detailed analysis.

### Key Coding Patterns to Follow

#### 1. Cryptographic Operations - Use Pure Functions

All cryptographic operations MUST be implemented as pure functions with no side effects:

```typescript
// ‚úÖ Good - Pure function
export function salty_encrypt(
  message: string,
  key: CryptoKey,
): Promise<string> {
  // No side effects, predictable output
}

// ‚ùå Bad - Stateful encryption
class Encryptor {
  private state: any;
  encrypt(message: string): Promise<string> {/* uses this.state */}
}
```

#### 2. Infrastructure Components - Use Classes

Logging, tracing, and utilities should use classes with proper encapsulation:

```typescript
// ‚úÖ Good - Class for stateful components
class Logger {
  private config: LoggerConfig;
  private metrics: PerformanceMetrics;

  info(message: string): void {/* ... */}
}

// ‚úÖ Good - Static utility class
class SecurityUtils {
  static createSecurityHeaders(): Headers {/* ... */}
}
```

#### 3. Error Handling - Use Custom Error Classes

Extend Error class for domain-specific errors:

```typescript
// ‚úÖ Good
class ApiError extends Error {
  constructor(message: string, public statusCode: number, public code: string) {
    super(message);
  }
}
```

#### 4. Type Safety - Use TypeScript Features

- Use interfaces for data contracts
- Use enums for constants
- Use generics for reusable components
- Use `as const` for immutable objects

#### 5. Async Patterns

Always use async/await over callbacks or raw promises:

```typescript
// ‚úÖ Good
async function processRequest(req: Request): Promise<Response> {
  const data = await validateRequest(req);
  return createResponse(data);
}
```

#### 6. Module Organization

- One primary export per file
- Group related types/interfaces at the top
- Use named exports over default exports
- Keep files focused on a single responsibility
