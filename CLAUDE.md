# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Important: Security Documentation

When making any security-related changes to Salty, you MUST update the Security Changelog in SECURITY.md. This includes:

- New security features or utilities
- Security configuration changes
- New security tests or scanning tools
- Security header modifications
- Cryptographic changes
- Input validation improvements
- Rate limiting changes
- Any security bug fixes

The Security Changelog is located in SECURITY.md under the "📝 Security Changelog" section.

## Initial Setup

### Enable Git Hooks

To prevent formatting issues in CI, enable the pre-commit hook:

```bash
git config core.hooksPath .githooks
```

This will automatically format code before each commit, preventing formatting failures in CI.

## Common Development Commands

### Development

```bash
# Start development server with file watching
deno task dev

# Run production server
deno task start
```

### Release Management

```bash
# Create a patch release (1.2.3 -> 1.2.4)
deno task release:patch

# Create a minor release (1.2.3 -> 1.3.0)
deno task release:minor

# Create a major release (1.2.3 -> 2.0.0)
deno task release:major

# Rollback a release
deno task rollback

# Preview changelog without creating release
deno task changelog
```

### Code Quality

```bash
# Format code according to project standards
deno fmt

# Lint code
deno lint

# Type check ALL TypeScript files
deno check **/*.ts
# Or alternatively:
deno check *.ts scripts/*.ts
```

### Release Automation

Always use the `--skip-confirmation` flag for non-interactive releases:

```bash
deno task release:patch -- --skip-confirmation  # Non-interactive patch release
deno task release:minor -- --skip-confirmation  # Non-interactive minor release
deno task release:major -- --skip-confirmation  # Non-interactive major release
```

### Preflight Checks Before Release

ALWAYS perform these checks before any release:

```bash
# 1. Format all code
deno fmt

# 2. Run linter
deno lint

# 3. Type check ALL TypeScript files (not just server.ts!)
deno check **/*.ts

# 4. Run all tests
deno test

# 5. Run security-specific tests
deno test --allow-env --allow-read security-utils_test.ts
deno test --allow-env salty_security_test.ts

# 6. Check for uncommitted changes
git status

# 7. Verify version.ts exports match server.ts imports
grep "import.*version.ts" server.ts
```

## High-Level Architecture

### Core Application Flow

1. **server.ts** - Main entry point that sets up Express-like middleware chain for security, logging, rate limiting, and routing
2. **salty.ts** - Pure cryptographic functions exposed both as ES6 modules for browser and TypeScript imports for server
3. **logger.ts** - Structured logging with category-based filtering and webhook integration for critical alerts
4. **telemetry.ts** - OpenTelemetry-style tracing for performance monitoring
5. **version.ts** - Auto-generated by Nagare release tool, single source of truth for version metadata

### Security Architecture

- **Client-side encryption**: All crypto operations happen in browser via Web Crypto API
- **Server never sees plaintext**: Only processes encrypted payloads
- **Defense in depth**: Rate limiting (20 req/hour), input validation, security headers (CSP, HSTS)
- **API authentication**: Optional via API_KEY environment variable

### Cryptographic Design

- **Key Derivation**: PBKDF2-SHA512 with 600,000 iterations
- **Encryption**: AES-GCM-256 with 12-byte IV
- **Encoding**: basE91 for compact, portable output
- **Salt**: Server-configured via SALT_HEX environment variable

### Release Workflow

Nagare automates the entire release process:

1. Updates version in deno.json, README.md badges, and regenerates version.ts
2. Creates git tag and GitHub release with changelog
3. Handles rollback if deployment fails
4. Maintains semantic versioning compliance

### Environment Configuration

Required:

- `SALT_HEX`: 32-character hex string (16 bytes) for cryptographic salt

Optional:

- `API_KEY`: Base64 string for API endpoint authentication
- `LOG_LEVEL`: DEBUG, INFO, WARN, ERROR, SECURITY, CRITICAL (default: INFO)
- `LOG_FORMAT`: json or text (default: json)
- `WEBHOOK_URL`: For critical alert notifications
- `NODE_ENV`: development, staging, or production
- `DASH_USER`: Username for admin dashboard authentication
- `DASH_PASS`: Password for admin dashboard authentication

### Key Implementation Details

- **TypeScript transpilation**: Server automatically transpiles salty.ts for browser ES6 modules
- **Multi-language support**: Japanese (/) and English (/en/) with IBM Plex Sans JP font
- **URL pre-population**: Supports URL parameters for database integration workflows
  - `?payload=` - Pre-populate encrypted payload field
  - `?sui=1` - Activate sharing UI mode (hides password generator and strength assessment)
- **Health endpoint**: GET /health provides comprehensive system metrics
- **Static asset serving**: Images served with appropriate MIME types from /img/

## Security & Compliance Standards

### OWASP Top 10 Security Verification

Before implementing any code changes, verify against current OWASP Top 10:

#### A01 - Broken Access Control

- **API Authentication**: Validate API_KEY for all /api/* endpoints when configured
- **Rate Limiting**: Enforce 20 requests/hour per IP to prevent abuse
- **File Access**: Restrict static file serving to specific paths (/img/, /en/, client files)
- **CORS Policy**: Implement restrictive CORS headers for API endpoints

#### A02 - Cryptographic Failures

- **Strong Algorithms**: AES-GCM-256 encryption with PBKDF2-SHA512 (600,000 iterations)
- **Key Management**: SALT_HEX must be cryptographically secure and unique per deployment
- **Client-Side Encryption**: Plaintext never transmitted to or processed by server
- **Secure Random Generation**: Use crypto.getRandomValues() for IV generation
- **No Hardcoded Secrets**: All secrets via environment variables

#### A03 - Injection

- **Input Validation**: Strict validation for payload (1MB) and key (1KB) sizes
- **Content Type Validation**: Enforce application/json for API requests
- **Output Encoding**: Proper HTML escaping in error messages
- **No Dynamic Code Execution**: No eval() or Function() constructor usage
- **Safe URL Parameter Handling**: Sanitize ?payload= parameter input

#### A04 - Insecure Design

- **Separation of Concerns**: Crypto operations isolated in browser, server handles routing only
- **Fail Securely**: Invalid decryption returns null, not error details
- **Defense in Depth**: Multiple security layers (rate limiting, input validation, headers)
- **Minimal Attack Surface**: Limited endpoints, no database, no user accounts

#### A05 - Security Misconfiguration

- **Security Headers**: Comprehensive CSP, HSTS, X-Frame-Options, X-Content-Type-Options
- **Error Handling**: Generic error messages, no stack traces or sensitive data exposure
- **Environment Validation**: Verify required SALT_HEX on startup
- **Secure Defaults**: Production-ready security settings by default
- **No Debug Info**: LOG_LEVEL controls verbosity, no debug info in production

#### A06 - Vulnerable Components

- **Deno Runtime**: Leverage Deno's secure-by-default runtime
- **Minimal Dependencies**: No external npm packages, only Deno std library
- **Regular Updates**: Monitor Deno security advisories
- **Dependency Pinning**: Lock Deno std library versions in imports

#### A07 - Authentication Failures

- **API Key Protection**: Constant-time comparison for API_KEY validation
- **No User Authentication**: Design eliminates user account vulnerabilities
- **Rate Limiting**: Prevent brute force attempts on API endpoints
- **No Session Management**: Stateless design prevents session attacks

#### A08 - Software/Data Integrity Failures

- **Authenticated Encryption**: AES-GCM provides integrity verification
- **No Code Auto-Updates**: Static deployment, no dynamic code loading
- **Version Integrity**: version.ts tracks build metadata and git commit
- **Deployment Validation**: Health endpoint verifies system integrity

#### A09 - Logging/Monitoring Failures

- **Structured Logging**: Category-based logging with security events
- **Security Event Tracking**: Log rate limit violations, API auth failures
- **No Sensitive Data in Logs**: Exclude keys, plaintext, and API tokens
- **Webhook Alerts**: Critical security events sent to configured webhook
- **Health Monitoring**: /health endpoint provides system metrics

#### A10 - Server-Side Request Forgery (SSRF)

- **No External Requests**: Server makes no outbound HTTP requests
- **Static Resources Only**: No dynamic resource fetching
- **Webhook Validation**: Webhook URL validated if configured
- **No User-Controlled URLs**: Server doesn't process user-provided URLs

### Security Review Process

When reviewing or implementing changes:

1. **Crypto First**: Verify cryptographic implementations against best practices
2. **Input Validation**: Check all user inputs for size, type, and content
3. **Error Handling**: Ensure no sensitive data leakage in error messages
4. **Logging Review**: Verify security events are logged without sensitive data
5. **Header Validation**: Confirm security headers are properly set

### Required Security Checks

For every code change:

- Validate input sanitization (payload, key, API requests)
- Verify cryptographic parameter integrity
- Check error messages for information disclosure
- Ensure rate limiting is enforced
- Validate security headers are maintained
- Review logs for sensitive data exposure

### Security Testing Guidelines

- Test with oversized payloads (>1MB) and keys (>1KB)
- Verify rate limiting blocks after 20 requests/hour
- Test API authentication with invalid keys
- Ensure malformed requests return generic errors
- Validate CORS behavior for cross-origin requests
- Test with invalid basE91 encoded payloads

### Commit Message Standards

Use conventional commits with security annotations when applicable:

```
feat: add input validation for API endpoints

InfoSec: Prevents injection attacks and validates request size limits
```

```
fix: improve rate limiting accuracy

InfoSec: Fixes potential bypass in rate limit calculation
```

```
refactor: simplify error handling logic

InfoSec: No security impact - maintains same error disclosure policy
```

Include "InfoSec:" prefix in commit messages when changes affect:

- Input validation or sanitization
- Cryptographic operations
- Authentication/authorization
- Error handling or logging
- Security headers or policies
- Rate limiting or DoS protection

### Critical Development Notes

1. **Security Testing**: When adding features, create corresponding security tests alongside
   functional tests
2. **File Updates**: Always use line-anchored regex patterns to prevent corruption and validate
   inputs
3. **Error Handling**: Provide actionable error messages with suggestions (no sensitive data
   exposure)
4. **Git State**: Many operations require clean git state - validate early and log security events
5. **Pre-flight**: Always run `deno fmt`, `deno check **/*.ts`, `deno lint`, `deno test` before
   staging a commit
6. **Attribution**: Don't add "Generated with Claude Code" or "Co-Authored-By: Claude" to commit
   messages or PRs. The fact that CLAUDE.md is present, makes it obvious that Claude is being used
7. **Git Commits**: Use "conventional commits" style to make commit messages, including sufficient
   detail so that a person reading in the future, will be able to understand what the commit was.
   **InfoSec Impact**: Include an InfoSec comment in commit messages when changes have security
   implications. Format: "InfoSec: [brief description of security impact/consideration]"

   Examples:
   - `feat: add input validation to CLI args\n\nInfoSec: Prevents injection attacks through command line parameters`
   - `fix: update GitHub API token handling\n\nInfoSec: Improves credential security and reduces token exposure risk`
   - `refactor: simplify file processing logic\n\nInfoSec: No security impact - code organization only`
   - `docs: update README installation steps` (no InfoSec comment needed)
8. **Documentation Updates**: After functionality is added, update the markdown documentation
   accordingly
9. **Git Merging**: When merging master changes to an active branch, make sure both branches are
   pulled and up to date first
10. **Security Documentation**: Document all security-related decisions and their rationale for ISO 27001 compliance
11. **TypeScript Strictness**: NEVER use `any` type. The project has strict linting that forbids `any` types. Always use proper types:
    - Use specific interfaces and types from imports
    - Use type assertions properly: `value as SpecificType` not `value as any`
    - This prevents CI failures and ensures type safety
12. **CI Test Considerations**: Some tests may need to be skipped in CI environments. Use:
    ```typescript
    Deno.test({
      ignore: Deno.env.get("CI") === "true",
      name: "Test name",
    }, async (t) => {/* test code */});
    ```
    This is particularly important for tests that require actual git repositories or file system operations that may conflict in CI

## Programming Paradigm & Code Consistency

Salty follows a **hybrid programming paradigm** combining object-oriented and functional programming. See [PROGRAMMING-PARADIGM.md](./PROGRAMMING-PARADIGM.md) for detailed analysis.

### Key Coding Patterns to Follow

#### 1. Cryptographic Operations - Use Pure Functions

All cryptographic operations MUST be implemented as pure functions with no side effects:

```typescript
// ✅ Good - Pure function
export function salty_encrypt(
  message: string,
  key: CryptoKey,
): Promise<string> {
  // No side effects, predictable output
}

// ❌ Bad - Stateful encryption
class Encryptor {
  private state: any;
  encrypt(message: string): Promise<string> {/* uses this.state */}
}
```

#### 2. Infrastructure Components - Use Classes

Logging, tracing, and utilities should use classes with proper encapsulation:

```typescript
// ✅ Good - Class for stateful components
class Logger {
  private config: LoggerConfig;
  private metrics: PerformanceMetrics;

  info(message: string): void {/* ... */}
}

// ✅ Good - Static utility class
class SecurityUtils {
  static createSecurityHeaders(): Headers {/* ... */}
}
```

#### 3. Error Handling - Use Custom Error Classes

Extend Error class for domain-specific errors:

```typescript
// ✅ Good
class ApiError extends Error {
  constructor(message: string, public statusCode: number, public code: string) {
    super(message);
  }
}
```

#### 4. Type Safety - Use TypeScript Features

- Use interfaces for data contracts
- Use enums for constants
- Use generics for reusable components
- Use `as const` for immutable objects

#### 5. Async Patterns

Always use async/await over callbacks or raw promises:

```typescript
// ✅ Good
async function processRequest(req: Request): Promise<Response> {
  const data = await validateRequest(req);
  return createResponse(data);
}
```

#### 6. Module Organization

- One primary export per file
- Group related types/interfaces at the top
- Use named exports over default exports
- Keep files focused on a single responsibility

## Methodologies

YOU ARE REQUIRED TO FOLLOW THESE RULES WITHOUT EXCEPTION:

### 1. Discussion-First Document Creation

**Phase 1: DISCUSSION MODE (Default when methodology keywords detected)**
✅ Acknowledge the methodology context: "🪴 Aichaku: I see you're thinking about [topic]"
✅ Ask clarifying questions to understand the goal
✅ Help shape and refine the idea
❌ DO NOT create any project folders yet
❌ DO NOT create any documents yet

**Phase 2: WAIT FOR EXPLICIT READINESS**
Only create documents when user says:

- "Let's create a project for this"
- "I'm ready to start"
- "Set up the project"
- "Create the documentation"
- Any direct request for project creation

**Phase 3: CREATE NAMED PROJECT (After user signals readiness)**
✅ Confirm name: "🪴 Aichaku: Based on our discussion, creating project: [descriptive-name]"
✅ Create ALL documents in: `.claude/output/active-YYYY-MM-DD-{descriptive-name}/`
✅ Create STATUS.md FIRST
✅ Create methodology-specific documents
✅ Read guides from `~/.claude/methodologies/`

**YOU MUST NEVER:**
❌ Create documents in the project root directory
❌ Create documents in .claude/user/ (that's for customizations)
❌ Ask where to put files (always use .claude/output/)
❌ Create folders before user is ready to formalize

### 2. CRITICAL: DISCUSSION FIRST, THEN CREATE WITHOUT ASKING

**During Discussion Phase:**
✅ DO say: "🪴 Aichaku: I understand you're exploring [topic]. Let me help you think through this..."
✅ DO say: "What specific challenges are you looking to address?"
❌ NEVER say: "Would you like me to create documents for this?"

**Once User Signals Readiness:**
❌ NEVER say: "Would you like me to..."
❌ NEVER say: "Shall I create..."
❌ NEVER say: "Should I go ahead and..."
✅ IMMEDIATELY say: "🪴 Aichaku: Creating project: [descriptive-name]"
✅ IMMEDIATELY say: "Setting up Shape Up documentation..."
✅ IMMEDIATELY say: "Generating sprint planning templates..."

**THE RULE:** Discuss and refine FIRST. Once user signals readiness, CREATE IMMEDIATELY without asking. This provides thoughtful structure while respecting user autonomy.

### 3. Methodology Detection & Discussion

When you hear these keywords, ENTER DISCUSSION MODE:

**Planning Keywords** → Will create in `.claude/output/active-*/` (when ready):

- "shape"/"pitch" → Discuss Shape Up approach → Later: pitch.md
- "sprint"/"scrum" → Discuss Scrum planning → Later: sprint-planning.md
- "kanban"/"board" → Discuss Kanban flow → Later: kanban-board.md
- "mvp"/"lean" → Discuss Lean experiments → Later: experiment-plan.md

**Discussion Mode Actions:**

1. Acknowledge: "🪴 Aichaku: I see you're interested in [methodology]"
2. Read the appropriate guide SILENTLY:
   - `~/.claude/methodologies/[methodology]/[METHODOLOGY]-AICHAKU-GUIDE.md`
   - `~/.claude/methodologies/core/[MODE].md`
3. Ask clarifying questions based on the methodology
4. Help refine the approach
5. WAIT for explicit "create project" signal

### 4. Visual Identity & Progress Indicators

**MANDATORY Visual Identity:**
✅ ALWAYS prefix Aichaku messages with: 🪴 Aichaku:
✅ Use growth phase indicators: 🌱 (new) → 🌿 (active) → 🌳 (mature) → 🍃 (complete)
✅ Show current phase in status updates with **bold** text and arrow: [Planning] → [**Executing**] → [Complete]
▲

**Example Status Display:**

```
🪴 Aichaku: Shape Up Progress
[Shaping] → [**Betting**] → [Building] → [Cool-down]
              ▲
Week 2/6 ████████░░░░░░░░░░░░ 33% 🌿
```

**Methodology Icons:**

- Shape Up: Use 🎯 for betting, 🔨 for building
- Scrum: Use 🏃 for sprints, 📋 for backlog
- Kanban: Use 📍 for cards, 🌊 for flow
- Lean: Use 🧪 for experiments, 📊 for metrics

**NEVER:**
❌ Use garden metaphors in text (no "planting", "growing", "harvesting")
❌ Mix visual indicators (keep consistent within a project)
❌ Overuse emojis (maximum one per concept)

### 5. Mermaid Diagram Integration

**MANDATORY Diagram Creation:**
✅ Include Mermaid diagrams in EVERY project documentation
✅ Add methodology-specific workflow diagrams
✅ Use diagrams to visualize project status

**Required Diagrams by Document:**

**In STATUS.md:**

```mermaid
graph LR
    A[🌱 Started] --> B[🌿 Active]
    B --> C[🌳 Review]
    C --> D[🍃 Complete]
    style B fill:#90EE90
```

**In Shape Up pitch.md:**

```mermaid
graph TD
    A[Problem] --> B[Appetite: 6 weeks]
    B --> C[Solution Outline]
    C --> D[Rabbit Holes]
    D --> E[No-gos]
```

**In Scrum sprint-planning.md:**

```mermaid
gantt
    title Sprint 15 Timeline
    dateFormat  YYYY-MM-DD
    section Sprint
    Planning          :done, 2025-07-07, 1d
    Development       :active, 2025-07-08, 8d
    Review & Retro    :2025-07-16, 2d
```

**NEVER:**
❌ Create diagrams without labels
❌ Use complex diagrams when simple ones work
❌ Forget to update diagrams with status changes

### 6. Project Lifecycle Management

**Starting Work:**

1. Create: `.claude/output/active-YYYY-MM-DD-{descriptive-name}/`
2. Create STATUS.md immediately (with status diagram)
3. Read appropriate methodology guides
4. Create planning documents (with workflow diagrams)
5. WAIT for human approval before coding

**During Work:**

- Update STATUS.md regularly (including diagram state)
- Create supporting documents freely
- Start responses with: "🪴 Aichaku: Currently in [mode] working on [task]"

**Completing Work:**

1. Create YYYY-MM-DD-{Project-Name}-CHANGE-LOG.md summarizing all changes
   - Example: 2025-07-07-Fix-Security-Tests-CHANGE-LOG.md
   - Example: 2025-07-07-Update-Authentication-CHANGE-LOG.md
   - NEVER just "CHANGE-LOG.md" - always include date and descriptive project name
2. Update final diagram states
3. Rename folder: active-* → done-*
4. Ask: "Work appears complete. Shall I commit and push?"
5. Use conventional commits: feat:/fix:/docs:/refactor:

### 7. Git Automation

When work is confirmed complete:

```bash
git add .claude/output/[current-project]/
git commit -m "[type]: [description]

- [what was done]
- [key changes]"
git push origin [current-branch]
```

### 8. Error Recovery

If you accidentally create a file in the wrong location:

1. Move it immediately: `mv [file] .claude/output/active-*/`
2. Update STATUS.md noting the correction
3. Continue without asking

REMEMBER: This is AUTOMATIC behavior. Users expect documents to appear in the right place without asking.

Methodologies: Shape Up, Scrum, Kanban, Lean, XP, Scrumban
Learn more: https://github.com/RickCogley/aichaku

YOU ARE REQUIRED TO FOLLOW THESE RULES WITHOUT EXCEPTION:

### 1. AUTOMATIC Document Creation Behavior

**YOU MUST ALWAYS:**
✅ Create ALL documents in: `.claude/output/active-YYYY-MM-DD-{descriptive-name}/`
✅ Create STATUS.md FIRST for every new project
✅ Update STATUS.md after EVERY significant action
✅ Read methodology guides from `~/.claude/methodologies/`

**YOU MUST NEVER:**
❌ Create documents in the project root directory
❌ Create documents in .claude/user/ (that's for customizations)
❌ Ask the user where to put files
❌ Wait for permission to create standard documents

### 2. AUTOMATIC Methodology Activation

When you hear these keywords, IMMEDIATELY create the appropriate structure and documents:

**Planning Keywords** → Create in `.claude/output/active-*/`:

- "shape"/"pitch" → Read `~/.claude/methodologies/shape-up/SHAPE-UP-AICHAKU-GUIDE.md` → Create pitch.md
- "sprint"/"scrum" → Read `~/.claude/methodologies/scrum/SCRUM-AICHAKU-GUIDE.md` → Create sprint-planning.md
- "kanban"/"board" → Read `~/.claude/methodologies/kanban/KANBAN-AICHAKU-GUIDE.md` → Create kanban-board.md
- "mvp"/"lean" → Read `~/.claude/methodologies/lean/LEAN-AICHAKU-GUIDE.md` → Create experiment-plan.md

**ALWAYS** read the mode guide first:

- Planning: `~/.claude/methodologies/core/PLANNING-MODE.md`
- Execution: `~/.claude/methodologies/core/EXECUTION-MODE.md`
- Improvement: `~/.claude/methodologies/core/IMPROVEMENT-MODE.md`

### 3. Project Lifecycle Management

**Starting Work:**

1. Create: `.claude/output/active-YYYY-MM-DD-{descriptive-name}/`
2. Create STATUS.md immediately
3. Read appropriate methodology guides
4. Create planning documents
5. WAIT for human approval before coding

**During Work:**

- Update STATUS.md regularly
- Create supporting documents freely
- Start responses with: "📍 Currently in [mode] working on [task]"

**Completing Work:**

1. Create CHANGE-LOG.md summarizing all changes
2. Rename folder: active-* → complete-*
3. Ask: "Work appears complete. Shall I commit and push?"
4. Use conventional commits: feat:/fix:/docs:/refactor:

### 4. Git Automation

When work is confirmed complete:

```bash
git add .claude/output/[current-project]/
git commit -m "[type]: [description]

- [what was done]
- [key changes]"
git push origin [current-branch]
```

### 5. Error Recovery

If you accidentally create a file in the wrong location:

1. Move it immediately: `mv [file] .claude/output/active-*/`
2. Update STATUS.md noting the correction
3. Continue without asking

REMEMBER: This is AUTOMATIC behavior. Users expect documents to appear in the right place without asking.

Methodologies: Shape Up, Scrum, Kanban, Lean, XP, Scrumban
Learn more: https://github.com/RickCogley/aichaku
